Both the player and computer grids are generated by Core JavaScript.

I included two buttons on the grid page. One reinitializes the game, allowing the player to either restart a game, or re-randomize ship placement. The other closes the open tab. Note that closing a tab that the window did not open (specifically, using self.close) is permitted in the most recent version of Chrome, but not in the most recent version of Firefox or Safari. I am aware this is not practical in a real web application implementation, but I wanted to add another button just to ensure that I met the project's requirements. The button works in all browsers if the game grid is opened via index.html rather than opening it directly from the file.

Text input didn't make much sense for Battleship, though select options could have been used to allow the user to place ships. I tried this briefly, however not having a method of displaying the ship under the mouse cursor ultimately made this more confusing for the player than it was worth, since they were still placing ships somewhat blindly with regard to orientation and encountering grid boundaries.

The user is only permitted to click on the computer grid. Furthermore, repeated clicks on the same grid cell are not permitted and do not consume a turn.

I chose to use innerHTML over DOM. This is evident in the grid generation (the generateTable() function) as well as in loading XML (in the getHighscores() function).

I've used XMLHttpRequest to load highscores.xml and populate a table with the information. Note that after its initial write, this table is not dynamic, since this is not part of the requirements for a Battleship implementation, though this could have been done using innerHTML with a global html variable. 

I adapted a particle animation which is cited in my code. The original example was a persistent canvas animation. I resized the canvas element and used setInterval, clearInterval, setTimeout, and clearTimeout to call the canvas element each time the player hits a computer ship. The canvas element is cleared preventatively using clearRect() each time the user hits a ship cell, in case subsequent hits are less than one second apart (the duration of the animation). Otherwise, setTimeout would be overwritten and the canvas element would run indefinitely. 

The animation code keeps an array of particles of variable size and speed (in both the x and y directions). The canvas is cleared every 30ms and the particles are redrawn at coordinates incremented by these speed values and particle size is decremented by 4%. To eliminate memory leaks, particles below a 10% size threshold are spliced from the particle array. 

There are two small shortcomings of the AI. First, it will only attempt to sink one ship at a time. That is, if the computer hits two ships that are adjacent, it will only pursue the first ship which it initially hit and will 'forget' about the second ship.  To handle this unusual situation would require either recursion, or up to four times the number of computer AI variables (in my implementation) to handle the extremely rare possibility of all five ships being hit while searching out the one that was first hit.  The second shortcoming occurs in an even more rare situation, and is a byproduct of the first shortcoming; namely, if the computer happens to hit a ship cell which has undiscovered ship cells on either side of it, but 'forgets' about this ship as described previously, there is the possibility that the computer will later hit the ship and encounter previously clicked cells in all adjacent positions of interest, yet it knows that it has not sunk a ship.

Both of these rare circumstances could be solved readily be giving the computer access to the game grid, but I didn't want to allow the computer to 'cheat' in this manner. Solving the second problem using logic could be done by having the computer check the closest cells, radiating outward from the discovered ship cell, but again we would run into the problem of saving previously discovered ships if we encountered an additional ship while doing this. Because this situation is so rare, I decided to simply force the computer to forget about the ship for which it found previously clicked cells on either side of its current position of interest.

Other than these two small quirks, the computer AI works well. After hitting a ship, the computer will search adjacent cells in a clockwise manner, starting with the cell directly above. It will bypass previously clicked cells, or locations which are not part of the grid. Once a subsequent ship cell is discovered, the ship's directional axis is known, and the computer will follow it either to the right or upward, depending on orientation. If this does not sink the ship, the computer will double back to its original starting point upon reaching a cell which does not belong to the desired ship. It will then progress in the opposite direction until the ship is sunk, at which point it will once again resume random selection.

The computer and player take turns making the first selection and the ship placement is generated randomly using the Math.random() function.



